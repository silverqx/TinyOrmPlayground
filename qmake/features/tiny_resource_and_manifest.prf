# Include Windows resource and manifest files.
defineTest(tiny_resource_and_manifest) {
    # Relevant for Windows build only
    !win32: return()
    # Relevant for exe or shared library
    !contains(TEMPLATE, ".*(lib|app)"): \
        return()
    # Library archive does not need RC or manifest file
    !CONFIG(shared, dll|shared|static|staticlib): \
    !CONFIG(dll, dll|shared|static|staticlib): \
        return()

    # Path to the resources folder, relative to the currently processed project
    isEmpty(2): resourcesFolder = resources
    else: resourcesFolder = $$2

    # Target's extension
    contains(TEMPLATE, ".*app"): targetExt = ".exe"
    else:contains(TEMPLATE, ".*lib"): targetExt = ".dll"

    # Windows Resource file
    rcFile = $$tiny_configure_cmake_rc($$resourcesFolder, $$targetExt)

    # Needed in the RC file, MinGW does not define _DEBUG macro
    mingw:CONFIG(debug, debug|release): DEFINES += _DEBUG

    RC_INCLUDEPATH = $$1
    RC_FILE = $$rcFile

    # Manifest file
    CONFIG -= embed_manifest_dll

    # Resource folder for the currently processed project
    resourcePath = $$tiny_get_resource_folder($$resourcesFolder)

    # On MSVC use EMBED and on MinGW injected through the RC file
    !mingw: \
        QMAKE_LFLAGS += \
            /MANIFEST:EMBED \
            /MANIFESTINPUT:$$shell_quote($$resourcePath/$${TARGET}$${targetExt}.manifest)

    export(DEFINES)
    export(RC_INCLUDEPATH)
    export(RC_FILE)
    export(CONFIG)
    export(QMAKE_LFLAGS)
}

# Substitute cmake variables in the Windows RC file, is better to reuse existing Windows
# RC file than manage two practically the same files.
defineReplace(tiny_configure_cmake_rc) {
    rcFile = $$absolute_path($$PWD/$$1/$${TARGET}.rc.in)
    exists(rcFile) {
        error( "Windows RC file $$1 passed to the tiny_configure_cmake_rc() does not\
                exists." )
    }

    rcFileContent = $$cat($$rcFile, blob)

    # Support OriginalFilename in the Windows RC file
    load(resolve_target)

    rcFileContent ~= s/@$${TARGET}_target@/$$TARGET
    rcFileContent ~= s/\\$<TARGET_FILE_NAME:$$TARGET>/$$basename(QMAKE_RESOLVED_TARGET)
    rcFileContent ~= s/\\$<TARGET_FILE_SUFFIX:$$TARGET>/$$2

    # Obtain a full filepath of the Windows RC file
    rcFilename = $$str_member($$rcFile, 0, -4)
    rcFilename = $$basename(rcFilename)
    rcFilepath = $$quote($$OUT_PWD/tmp/$$rcFilename)

    !write_file($$rcFilepath, rcFileContent) {
        error( "Can not write to the file $${rcFilepath}." )
    }

    return($$rcFilepath)
}

# Find resource folder for the currently processed project, needed because src.pro has
# unusual location, is in the subfolder.
defineReplace(tiny_get_resource_folder) {
    folder = $$absolute_path($$1, $$_PRO_FILE_PWD_)

    exists($$folder): return($$folder)

    error( "Can not find the 'resources' folder for $$basename(_PRO_FILE_) project,\
            expected folder location is $$_PRO_FILE_PWD_/resources." )
}
